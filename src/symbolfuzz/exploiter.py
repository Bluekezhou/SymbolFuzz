#!/usr/bin/env python
# coding=utf-8

"""
Module name: Exploiter.py
Create by:   Bluecake
Description: Basic class for automatic exploitation
"""

import os
from pwn import * 
from triton import OPCODE, Instruction
import logging
from emulator import *
from solver import *
import crash


"""
A basic class for exploitation framework.
Provide basic functions for higher level exploitation
"""
class Exploiter(object):

    def __init__(self, binary, crashfile):

        self.binary = binary
        self.crashfile = crashfile

        self.crashType = None
        self.src = []
        self.taintedData = list()
    

    """
    New and init an emulator
    """
    def initEmulator(self):

        emulator = Emulator(self.binary)
        def isTaintable(emulator, offset):
                return True      
        emulator.initialize()
        emulator.add_callback('taint_check', isTaintable)        
        data = open(self.crashfile).read()
        emulator.set_input(data)
        
        return emulator

    
    """
    Get crash type. Supported type includes:
        NO_CRASH, not any type of crash
        CONTROL_PC, pc address can be control by input
        SHELLCODE, is able to execute inputed shellcode
    """
    def getCrashType(self):

        if self.crashType:
            return self.crashType

        emulator = self.initEmulator()
        emulator.show_inst = False
        pc = emulator.getpc()

        try:
            while pc:
                pc = emulator.process()
            self.crashType = crash.NO_CRASH

        except IllegalPcException:
            log.info("Detecting crash info at " + hex(pc))
            self.crash_point = (pc, emulator.inst_count - 1)
            title('crash_point', self.crash_point)
            self.input_len = emulator.read_count
            self.crachstart = emulator.getreg('esp') - 4
            self.taintedData = emulator.triton.getTaintedMemory()
            #self.dst = range(esp, esp + 4)
            self.crashType = crash.CONTROL_PC

        except IllegalInstException:
            log.info("Detecting executing shellcode at " + hex(emulator.getpc()))
            self.crash_point = (pc, emulator.inst_count -1)
            title('crash_point', self.crash_point)
            self.input_len = emulator.read_count
            self.crachstart = emulator.getpc()
            self.taintedData = emulator.triton.getTaintedMemory()
            self.crashType = crash.SHELLCODE

        return self.crashType
    
    def setdst(self,dst):
        self.dst = dst#range(self.crachstart, self.crachstart + len)
    '''
    def gettainedmemory(self):
            return getTaintedMemory
    '''

    """
    Get the list of memory address which cause program crash
    """
    def getCrashMemory(self):
        return self.crachstart


    """
    
    """
    def getControlMemory(self):
        pass

    """

    """
    def getControlShellcode(self):
        pass

    def getcrash_point(self):
        return self.crash_point

    """
    Create input stream which can control eip to target value
    """
    def pcPayload(self, pc):

        #if self.crashType != crash.CONTROL_PC:
        #    return False
        
        initInput = open(self.crashfile).read()
        solver = InputSolver(self.binary)
        solver.setGoodSYMbyte(0)
        solver.set_breakpoint(self.crash_point)
        data = open(self.crashfile).read()
        solver.set_input(data, self.input_len) 
        print self.dst , pc
        answer = solver.solveMemory(self.dst, pc)
        title('answer',answer)
        #print '[-] answer' , answer ,'[-]'
        payload = {}
        if len(answer)>0:
            payload = solver.createInput(answer)
        return payload
